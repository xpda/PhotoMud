'Photo Mud is licensed under Creative Commons BY-NC-SA 4.0
'https://creativecommons.org/licenses/by-nc-sa/4.0/

Imports System.Net.Http
Imports System.Collections.Generic
Imports System.IO
Imports System.Text
Imports System.Text.RegularExpressions

Imports System.Data
Imports MySql.Data.MySqlClient

Imports Newtonsoft.Json.Linq


Public Module bugMain

  Structure GeocodeResponse
    Dim address_component As String
    Dim type As String
  End Structure

  '  Structure taxrec
  ' Dim rank As String
  ' Dim taxon As String
  ' Dim descr As String
  ' Dim taxid As String
  ' Dim parentid As String
  ' Dim imageCounter As Integer
  ' Dim childimageCounter As Integer
  ' Dim link As String
  ' Dim authority As String
  ' End Structure

  Public Class taxrec
    Public rank As String = ""
    Public taxon As String = ""
    Public descr As String = ""
    Public taxid As String = ""
    Public parentid As String = ""
    Public phylum As String = ""
    Public imageCounter As Integer = 0
    Public childimageCounter As Integer = 0
    Public link As String = ""
    Public spidercat As String = ""
    Public bugguide As String = ""
    Public taxlink As String = ""
    Public authority As String = ""
    Public extinct As Boolean = False ' string in database
    Public parentTsn As Integer = 0 ' not in database, used for list pages
    Public gbifID As String = "" ' not in database, used for list pages
    Public gbifParent As String = "" ' not in database, used for list pages
    Public gbifUsable As String = "" ' not in taxatable, in gbif
    Public paleo As New paleorec
    Public iucnStatus As String = "" ' not in taxatable, in iucn
    Public iucnTrend As String = "" ' not in taxatable, in iucn
    Public iucnYear As String = "" ' not in taxatable, in iucn
    Public iucnID As String = "" ' not in taxatable, in iucn
    Public iucnAssessmentID As String = "" ' not in taxatable, in iucn
    Public iucnVersion As String = "" ' not in taxatable, in iucn
    Public itistsn As Integer = 0

    ' old wikirec stuff, now in oddinfo
    Public synonyms As New List(Of String)
    Public synauth As New List(Of String)
    Public syresource As New List(Of String)
    Public wikipediaPageID As String = ""
    Public commonNames As New List(Of String)
    Public commonWikiLink As String = ""
    Public hodges As String = ""
    Public wikidataid As String = ""
    Public ambigLink As String = ""
    Public unimportant As Integer = 0 ' tells whether it's an autogenerated ancestor

  End Class


  Class imagerec
    Public imageid As Integer = 0
    Public filename As String = ""
    Public photodate As String = ""
    Public dateadded As String = ""
    Public modified As String = ""
    Public taxonid As String = ""
    Public gps As String = ""
    Public elevation As String = ""
    Public rating As Integer = 0
    Public confidence As Integer = 0
    Public remarks As String = ""
    Public originalpath As String = ""
    Public bugguide As Integer = 0
    Public inaturalist As Integer = 0
    Public size As String = ""
    Public location As String = ""
    Public county As String = ""
    Public state As String = ""
    Public country As String = ""
    Public imageSetID As Integer = 0
  End Class

  Class paleorec
    Public origID As Integer = 0
    Public taxID As Integer = 0
    Public flags As String = ""
    Public name As String = ""
    Public rank As String = ""
    Public authority As String = ""
    Public commonname As String = ""
    Public difference As String = ""
    Public acceptedID As Integer = 0
    Public acceptedName As String = ""
    Public acceptedRank As String = ""
    Public parentID As Integer = 0
    Public referenceID As Integer = 0
    Public extant As String = ""
    Public nOccurences As Integer = 0
    Public earlyinterval As String = ""
    Public lateinterval As String = ""
    Public nTaxon As Integer = 0
    Public nExtant As Integer = 0
    Public phylum As String = ""
    Public cclass As String = ""
    Public order As String = ""
    Public family As String = ""
    Public genus As String = ""
    Public typeTaxon As String = ""
  End Class

  Public gbifDatasets As List(Of String) = {
    "214c3109-d37a-40f8-9c24-5b6e59915394",
    "2d59e5db-57ad-41ff-97d6-11f5fb264527",
    "3e812f13-bd5f-46b6-9bae-710766be526d",
    "47f16512-bf31-410f-b272-d151c996b2f6",
    "598678e4-323c-49dc-8eb7-3a96ac72d472",
    "65c9103f-2fbf-414b-9b0b-e47ca96c5df2",
    "71e3fb9b-34ed-43d9-97d2-a829918828b2",
    "7ddf754f-d193-4cc9-b351-99906754a03b",
    "99948a8b-63b2-41bf-9d10-6e007e967789",
    "9ca92552-f23a-41a8-a140-01abaa31c931",
    "a5358a8d-9b1a-43a3-b769-50d3e6ef8bd9",
    "af66d4cf-0fd2-434b-9334-9806a5efa6f7",
    "bf3db7c9-5e5d-4fd0-bd5b-94539eaf9598",
    "c33ce2f2-c3cc-43a5-a380-fe4526d63650",
    "ca694ebf-2b52-4c67-b2e1-0f423149401c",
    "d9a4eedb-e985-4456-ad46-3df8472e00e8",
    "e0a61544-c923-4fd7-8ed1-9b692655cf6b",
    "90d9e8a6-0ce1-472d-b682-3451095dbc5a",
    "fbab0194-b923-49d4-9848-1b3279a6673e"}.ToList

  Public itisRankID As New Dictionary(Of String, Integer)(System.StringComparer.OrdinalIgnoreCase)
  Public itisRanks As New Dictionary(Of Integer, String)
  Public states As New Dictionary(Of String, String)(System.StringComparer.OrdinalIgnoreCase)
  Public mainRank As New List(Of String)

  Public nodeMatchColor As Color = Color.Cornsilk
  Public queryNames As New List(Of String) ' used by frmexpore and frmbugphotos
  Public useQuery As Boolean = False ' for frmExplore and frmbugphotos

  Public iniBugPath As String
  Public lastbugTaxon As String = ""
  Public lastbugTaxid As String = ""
  Public lastbugTaxonID As String = ""
  Public lastbugCommon As String = ""
  Public lastbugLocation As String = ""
  Public lastbugCounty As String = ""
  Public lastbugState As String = ""
  Public lastbugCountry As String = ""
  Public lastbugGPS As String = ""
  Public lastbugRating As String = ""
  Public lastbugSize As String = ""
  Public lastbugConfidence As String = ""
  Public lastbugRemarks As String = ""
  Public lastbugBugguide As String = ""
  Public lastbugiNaturalist As String = ""
  Public bugDBEnabled As Boolean = True
  Public dbAllowed As Integer = 1
  Public lastbugLocationAutocomplete As AutoCompleteStringCollection = Nothing
  Public iniBugPixelsPerMM As Double = 274.5 ' gx1: 268.4 macro, 56.5 for zoom, gh4: 274.5 macro, 57.8 zoom

  Public bugPrevFilename As String = ""

  Public cookies As CookieContainer
  Public handler As HttpClientHandler
  Public qClient As HttpClient ' need these for cookies

  Public commonCaps As New List(Of String)

  'Public QueryTaxon As String = ""  ' for shortcut -- temporary!

  Sub buginit()

    states.Add("Alabama", "AL")
    states.Add("Alaska", "AK")
    states.Add("Arizona", "AZ")
    states.Add("Arkansas", "AR")
    states.Add("California", "CA")
    states.Add("Colorado", "CO")
    states.Add("Connecticut", "CT")
    states.Add("Delaware", "DL")
    states.Add("Florida", "FL")
    states.Add("Georgia", "GA")
    states.Add("Hawaii", "HI")
    states.Add("Idaho", "ID")
    states.Add("Illinois", "IL")
    states.Add("Indiana", "IN")
    states.Add("Iowa", "IA")
    states.Add("Kansas", "KS")
    states.Add("Kentucky", "KY")
    states.Add("Louisiana", "LA")
    states.Add("Maine", "ME")
    states.Add("Maryland", "MD")
    states.Add("Massachusetts", "MA")
    states.Add("Michigan", "MI")
    states.Add("Minnesota", "MN")
    states.Add("Mississippi", "MS")
    states.Add("Missouri", "MO")
    states.Add("Montana", "MT")
    states.Add("Nebraska", "NE")
    states.Add("Nevada", "NV")
    states.Add("New Hampshire", "NH")
    states.Add("New Jersey", "NJ")
    states.Add("New Mexico", "NM")
    states.Add("New York", "NY")
    states.Add("North Carolina", "NC")
    states.Add("North Dakota", "ND")
    states.Add("Ohio", "OH")
    states.Add("Oklahoma", "OK")
    states.Add("Oregon", "OR")
    states.Add("Pennsylvania", "PA")
    states.Add("Rhode Island", "RI")
    states.Add("South Carolina", "SC")
    states.Add("South Dakota", "SD")
    states.Add("Tennessee", "TN")
    states.Add("Texas", "TX")
    states.Add("Utah", "UT")
    states.Add("Vermont", "VT")
    states.Add("Virginia", "VA")
    states.Add("Washington", "WA")
    states.Add("West Virginia", "WV")
    states.Add("Wisconsin", "WI")
    states.Add("Wyoming", "WY")
    states.Add("Puerto Rico", "PR")

    itisRankID.Add("kingdom", 10)
    itisRankID.Add("subkingdom", 20)
    itisRankID.Add("infrakingdom", 25)
    itisRankID.Add("superphylum", 27)
    itisRankID.Add("phylum", 30)
    itisRankID.Add("subphylum", 40)
    itisRankID.Add("infraphylum", 45)
    itisRankID.Add("superclass", 50)
    itisRankID.Add("class", 60)
    itisRankID.Add("subclass", 70)
    itisRankID.Add("infraclass", 80)
    itisRankID.Add("superorder", 90)
    itisRankID.Add("order", 100)
    itisRankID.Add("suborder", 110)
    itisRankID.Add("infraorder", 120)
    itisRankID.Add("section", 124)
    itisRankID.Add("subsection", 126)
    itisRankID.Add("superfamily", 130)
    itisRankID.Add("epifamily", 135)
    itisRankID.Add("family", 140)
    itisRankID.Add("subfamily", 150)
    itisRankID.Add("supertribe", 155)
    itisRankID.Add("tribe", 160)
    itisRankID.Add("subtribe", 170)
    itisRankID.Add("genus", 180)
    itisRankID.Add("subgenus", 190)
    itisRankID.Add("species", 220)
    itisRankID.Add("subspecies", 230)
    itisRankID.Add("variety", 240)

    itisRanks.Add(10, "kingdom")
    itisRanks.Add(20, "subkingdom")
    itisRanks.Add(25, "infrakingdom")
    itisRanks.Add(27, "superphylum")
    itisRanks.Add(30, "phylum")
    itisRanks.Add(40, "subphylum")
    itisRanks.Add(45, "infraphylum")
    itisRanks.Add(50, "superclass")
    itisRanks.Add(60, "class")
    itisRanks.Add(70, "subclass")
    itisRanks.Add(80, "infraclass")
    itisRanks.Add(90, "superorder")
    itisRanks.Add(100, "order")
    itisRanks.Add(110, "suborder")
    itisRanks.Add(120, "infraorder")
    itisRanks.Add(124, "section")
    itisRanks.Add(126, "subsection")
    itisRanks.Add(130, "superfamily")
    itisRanks.Add(135, "epifamily")
    itisRanks.Add(140, "family")
    itisRanks.Add(150, "subfamily")
    itisRanks.Add(155, "supertribe")
    itisRanks.Add(160, "tribe")
    itisRanks.Add(170, "subtribe")
    itisRanks.Add(180, "genus")
    itisRanks.Add(190, "subgenus")
    itisRanks.Add(220, "species")
    itisRanks.Add(230, "subspecies")
    itisRanks.Add(240, "variety")

    mainRank.Add("phylum")
    mainRank.Add("class")
    mainRank.Add("order")
    mainRank.Add("superfamily")
    mainRank.Add("family")
    mainRank.Add("tribe")
    mainRank.Add("genus")
    mainRank.Add("species")
    mainRank.Add("subspecies")
    mainRank.Add("variety")

    commonCaps = New List(Of String)
    Using ds As DataSet = getDS("select * from commoncaps order by word")
      For Each dr As DataRow In ds.Tables(0).Rows
        commonCaps.Add(dr("word"))
      Next dr
    End Using

    cookies = New CookieContainer
    handler = New HttpClientHandler
    handler.CookieContainer = cookies
    qClient = New HttpClient(handler) ' need this for cookies
    ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 Or SecurityProtocolType.Tls Or SecurityProtocolType.Tls11 Or SecurityProtocolType.Tls12

  End Sub

  Sub linkBugPhotos()
    ' link the tagged images in the bug database -- changes the database only.

    Dim setID As Integer
    Dim fName As String
    Dim i As Integer
    Dim nLinked As Integer = 0
    Dim exists As Boolean = False
    Dim result As MsgBoxResult

    If tagPath.Count >= 8 Then
      result = MsgBox(tagPath.Count & " files are tagged. Go ahead?", MsgBoxStyle.OkCancel)
      If result <> MsgBoxResult.Yes And result <> MsgBoxResult.Ok Then Exit Sub
    End If

    setID = 0
    For i = 0 To tagPath.Count - 1
      fName = Path.GetFileName(tagPath(i))
      exists = True
      If Not eqstr(Path.GetDirectoryName(tagPath(i)), iniBugPath) Then ' different source and target folders
        fName = getTargetFilename(iniBugPath, tagPath(i), exists) ' get the output filename (last match, if more than one)
      End If
      If exists Then
        saveImageSet(fName, setID) ' setID is assigned in the first call, byref
        nLinked += 1
      End If
    Next i

    MsgBox(nLinked & " images were linked.", MsgBoxStyle.OkCancel)

  End Sub

  Function mergeMatches(matches As List(Of taxrec), gmatches As List(Of taxrec)) As List(Of taxrec)

    ' merges taxrec lists, removes dups from second, must be sorted by taxon on input

    Dim ms As New List(Of taxrec)
    Dim taxa As New List(Of String)
    Dim i1, i2 As Integer


    'ms.AddRange(matches)
    'ms.AddRange(gmatches)
    'Return ms

    i1 = 0 : i2 = 0
    Do While i1 < matches.Count
      Do While i2 < gmatches.Count AndAlso gmatches(i2).taxon < matches(i1).taxon
        ms.Add(gmatches(i2))
        i2 += 1
      Loop
      If i2 < gmatches.Count AndAlso gmatches(i2).taxon = matches(i1).taxon Then i2 += 1

      ms.Add(matches(i1))
      i1 += 1
    Loop

    If i2 < gmatches.Count AndAlso i1 < matches.Count AndAlso gmatches(i2).taxon = matches(i1).taxon Then i2 += 1
    Do While i2 < gmatches.Count
      ms.Add(gmatches(i2))
      i2 += 1
    Loop

    Return ms


  End Function

  Function getImageRecbyID(imageid As String) As imagerec

    ' gets an imagerec from the taxa database, based on the image id

    Dim dr As DataRow
    Dim irec As New imagerec

    Using ds As DataSet = getDS("select * from images where imageid = @parm1", imageid)

      If ds IsNot Nothing AndAlso ds.Tables(0).Rows.Count <> 1 Then
        Return irec
      Else
        dr = ds.Tables(0).Rows(0)
        irec = getimagerecDr(dr)    ' load drow into irec
      End If

    End Using

    Return irec

  End Function


  Function getImageRec(fname As String) As imagerec

    ' gets an imagerec from the taxa database, based on the file name.

    Dim dr As DataRow
    Dim irec As New imagerec

    Using ds As DataSet = getDS("select * from images where filename = @parm1", fname)

      If ds IsNot Nothing AndAlso ds.Tables(0).Rows.Count <> 1 Then
        Return irec
      Else
        dr = ds.Tables(0).Rows(0)
        irec = getimagerecDr(dr)    ' load drow into irec
      End If
    End Using

    Return irec

  End Function

  Function getimagerecDr(dr As DataRow) As imagerec

    Dim irec As New imagerec

    ' load dr into irec
    irec.imageid = dr.Item("imageid")
    irec.filename = dr.Item("filename")
    If IsDBNull(dr.Item("photodate")) Then irec.photodate = "" Else irec.photodate = dr.Item("photodate")
    If IsDBNull(dr.Item("dateadded")) Then irec.dateadded = "" Else irec.dateadded = dr.Item("dateadded")
    If IsDBNull(dr.Item("modified")) Then irec.modified = "" Else irec.modified = dr.Item("modified")
    irec.taxonid = dr.Item("taxonid")
    irec.gps = dr.Item("gps")
    irec.elevation = dr.Item("elevation")
    irec.rating = dr.Item("rating")
    irec.confidence = dr.Item("confidence")
    irec.remarks = dr.Item("remarks")
    irec.originalpath = dr.Item("originalpath")
    irec.bugguide = dr.Item("bugguide")
    irec.inaturalist = dr.Item("inaturalist")
    irec.size = dr.Item("size")
    irec.location = dr.Item("location")
    irec.county = dr.Item("county")
    irec.state = dr.Item("state")
    irec.country = dr.Item("country")

    If irec.imageid > 0 Then ' check for imagesets
      Dim k As Integer = getScalar("select setid from imagesets where imageid = @parm1 and setid > 0", irec.imageid)
      irec.imageSetID = k
    End If

    Return irec

  End Function

  Function getTaxrecByID(ByVal taxid As String, addon As Boolean) As taxrec
    ' gbif is no longer used -- taxid should never start with g. 10-2-2020

    Dim m As New taxrec

    If Not IsNumeric(taxid) Then Return m

    Using ds As DataSet = getDS("select * from taxatable where taxid = @parm1", taxid)
      If ds IsNot Nothing Then
        If ds.Tables(0).Rows.Count > 1 Then Stop
        If ds.Tables(0).Rows.Count = 1 Then m = getTaxrec(ds.Tables(0).Rows(0), addon)
      End If
    End Using


    Return m

  End Function

  Function getTaxrec(ByRef dr As DataRow, addon As Boolean) As taxrec

    Dim match As New taxrec

    ' load drow into match
    match.rank = dr("rank")
    match.taxon = dr("taxon")
    match.descr = dr("descr")
    match.taxid = dr("taxid")
    match.parentid = dr("parentid")
    match.phylum = dr("phylum")
    match.imageCounter = dr("imagecounter")
    match.childimageCounter = dr("childimagecounter")
    match.link = dr("link")
    match.spidercat = dr("spidercat")
    match.bugguide = dr("bugguide")
    match.taxlink = dr("taxlink")
    match.authority = match.authority.Replace(" and ", " & ")
    If eqstr(dr("extinct"), "extinct") Or eqstr(dr("extinct"), "true") Or eqstr(dr("extinct"), "1") Then match.extinct = True Else match.extinct = False
    match.authority = dr("authority")

    If addon Then taxrecAddon(match)
    Return match

  End Function


  Function getpaleoTaxrec(dr As DataRow, addon As Boolean) As taxrec
    ' get rank, taxon, etc from spider to a taxrec
    Dim m As New taxrec

    If Not IsDBNull(dr("taxon_name")) Then m.taxon = dr("taxon_name").trim
    If Not IsDBNull(dr("taxon_rank")) Then m.rank = dr("taxon_rank").trim
    If Not IsDBNull(dr("taxon_attr")) Then m.authority = dr("taxon_attr").trim
    If Not IsDBNull(dr("taxon_no")) Then m.paleo.taxID = dr("taxon_no")
    If Not IsDBNull(dr("parent_no")) Then m.paleo.parentID = dr("parent_no")
    If Not IsDBNull(dr("is_extant")) Then
      m.paleo.extant = dr("is_extant")
      m.extinct = eqstr(dr("is_extant").trim, "extinct")
    End If
    If Not IsDBNull(dr("common_name")) Then m.descr = dr("common_name").trim

    m.link = ""
    If addon Then taxrecAddon(m)

    If m.taxlink = "" AndAlso m.paleo.taxID > 0 Then
      m.taxlink = "https://paleobiodb.org/classic/basicTaxonInfo?taxon_no=" & m.paleo.taxID
    End If

    Return m

  End Function

  Function getPaleoRec(dr As DataRow) As paleorec

    Dim prec As New paleorec

    prec.origID = dr("orig_no")
    prec.taxID = dr("taxon_no")
    prec.flags = dr("flags")
    prec.name = dr("taxon_name")
    prec.rank = dr("taxon_rank")
    prec.authority = dr("taxon_attr")
    prec.authority = prec.authority.Replace(" and ", " & ")
    prec.commonname = dr("common_name")
    prec.difference = dr("difference")
    prec.acceptedID = dr("accepted_no")
    prec.acceptedName = dr("accepted_name")
    prec.acceptedRank = dr("accepted_rank")
    prec.parentID = dr("parent_no")
    prec.referenceID = dr("reference_no")
    prec.extant = dr("is_extant")
    prec.nOccurences = dr("n_occs")
    prec.earlyinterval = dr("early_interval")
    prec.lateinterval = dr("late_interval")
    prec.nTaxon = dr("taxon_size")
    prec.nExtant = dr("extant_size")
    prec.phylum = dr("phylum")
    prec.cclass = dr("class")
    prec.order = dr("oorder")
    prec.family = dr("family")
    prec.genus = dr("genus")
    prec.typeTaxon = dr("type_Taxon")

    Return prec

  End Function

  Function compareAuthority(a1 As String, a2 As String) As Boolean

    ' compares the first word and date of two authorities, true = match

    Dim s1, s2 As String
    Dim rm As RegularExpressions.Match

    rm = Regex.Match(a1, "^(\(?([\p{L}]*)[^[:alpha:]]\)?.*([0-9]{4}))$")


    's1 = Regex.Replace(a1, "^(\(?([\p{L}]+?)[^[:alpha:]]\)?.*([0-9]{4}))$", "$2=$3")

    s1 = Regex.Replace(a1, "^(\(?([\p{L}]*)[^[:alpha:]]\)?.*([0-9]{4}))$", "$2 $3")
    s2 = Regex.Replace(a2, "^(\(?([\p{L}]*)[^[:alpha:]]\)?.*([0-9]{4}))$", "$2 $3")
    's2 = Regex.Replace(a2, "^(\(?([[:alpha:]]+?)[^[:alpha:]]\)?.*([0-9]{4}))$", "$2 $3")
    Return s1.ToLower = s2.ToLower

  End Function

  Function getPaleo(m As taxrec, allowDifference As Boolean) As paleorec

    ' get a matching paleo orig_no.

    Dim prec As New paleorec
    Dim attr As String
    Dim diffq As String = ""

    If Not allowDifference Then diffq = " and difference = ''"

    Using ds As DataSet = getDS("select * from paleo.tax where taxon_name = @parm1 and taxon_rank = @parm2" & diffq, m.taxon, m.rank)

      If ds.Tables(0).Rows.Count = 0 Then Return New paleorec

      For Each dr As DataRow In ds.Tables(0).Rows
        attr = dr("taxon_attr")
        prec = getPaleoRec(dr)
        If compareAuthority(attr, m.authority) Then Return prec

        ' too many indirect recurive calls:
        'parentName = getScalar("select taxon_name from paleo.tax where taxon_no = @parm1" & diffq & " limit 1", dr("parent_no"))
        ' check ancestor
        'anc = getancestors(m, 27, False, "phylum")
        'If isAncestor(anc, parentName, 0) Then Return prec
        'If dr("family") <> "" Then
        ' If isAncestor(anc, dr("family"), 0) Then Return prec
        ' Else ' family blank
        ' If isAncestor(anc, dr("oorder"), 0) Then Return prec
        ' End If
      Next dr

      If ds.Tables(0).Rows.Count = 1 Then Return prec Else Return New paleorec ' is close enough ok?

    End Using

  End Function

  Sub taxrecAddon(ByRef m As taxrec)

    ' load up the non-database things into m

    Dim s As String
    Dim k As Integer
    Dim ss() As String
    Dim dr As DataRow
    Dim sq As List(Of String)
    Dim prec As paleorec

    prec = getPaleo(m, False)
    If prec.taxID <> 0 Then
      If m.authority = "" Then m.authority = prec.authority
      If eqstr(prec.extant, "extinct") Then m.extinct = True
      If m.paleo.taxID = 0 Then m.paleo = prec
    End If

    's = getScalar("select is_extant from paleo.tax where taxon_name = @parm1 and difference = ''", m.taxon)
    'If eqstr(s, "extinct") And Not m.extinct Then Stop

    If m.itistsn = 0 Then
      Using ds As DataSet = getDS("select * from itis.taxonomic_units where name_usage = 'valid' and kingdom_id = 5 and complete_name = @parm1", m.taxon)
        If ds.Tables(0).Rows.Count = 1 Then
          m.itistsn = ds.Tables(0).Rows(0)("tsn")
          m.parentTsn = ds.Tables(0).Rows(0)("parent_tsn")
        End If
      End Using
    Else
      If m.parentTsn = 0 Then
        k = getScalar("select parent_tsn from itis.taxonomic_units where tsn = @parm1", m.itistsn)
        'If IsNumeric(v) Then m.parentTsn = v
        m.parentTsn = k
      End If
    End If

    m.iucnStatus = ""
    m.iucnTrend = ""
    m.iucnYear = ""
    m.iucnID = ""
    m.iucnAssessmentID = ""
    m.iucnVersion = ""

    Using ds As DataSet = getDS("select * from iucn where name = @parm1;", m.taxon)
      If ds.Tables(0).Rows.Count = 1 Then
        dr = ds.Tables(0).Rows(0)
        m.iucnStatus = dr("status")
        m.iucnTrend = dr("populationtrend")
        m.iucnYear = dr("yearassessed")
        m.iucnID = dr("speciesid")
        m.iucnAssessmentID = dr("assessmentid")
        m.iucnVersion = dr("criteriaversion")
      End If
    End Using

    m.commonNames = New List(Of String)

    ' get the old wikirec (now part of taxrec) from oddinfo
    If m.taxid <> "" Then
      Using ds As DataSet = getDS("select * from oddinfo where taxid = @parm1", m.taxid)
        If ds IsNot Nothing AndAlso ds.Tables(0).Rows.Count = 1 Then

          dr = ds.Tables(0).Rows(0)

          s = ""
          If m.taxid <> "" Then
            s = dr("commonnames")
            ss = s.Split("|")
            If ss.Count >= 1 AndAlso ss(0) <> "" Then m.commonNames = ss.ToList ' replaces anything already here (like gbif)
          End If

          m.ambigLink = dr("ambiglink")
          m.unimportant = dr("unimportant")

          m.synonyms = New List(Of String)
          m.synauth = New List(Of String)

          m.wikipediaPageID = dr("wikipediaPageID")
          m.commonWikiLink = dr("commonwikilink")
          m.hodges = dr("hodges")
          m.wikidataid = dr("wikidataid")
          m.ambigLink = dr("ambiglink")
          m.unimportant = dr("unimportant")
        End If
      End Using

      If m.commonNames.Count = 0 AndAlso m.descr <> "" AndAlso
           Not m.descr.ToLower.StartsWith("hodges") Then
        sq = m.descr.ToLower.Split(" ").ToList
        s = ""
        For i As Integer = 0 To sq.Count - 1
          If commonCaps.IndexOf(sq(i)) >= 0 Then s &= StrConv(sq(i), VbStrConv.ProperCase) & " " Else s &= sq(i) & " "
        Next i
        m.commonNames.Add(s.Trim) ' andalso Not m.descr.Contains(" and ") 
      End If

    End If

  End Sub

  Function taxaLabel(ByVal match As taxrec, ByVal verbose As Boolean, ByVal isQuery As Boolean) As String

    ' get a taxon label for treeview, etc.

    Dim s, descr As String

    s = match.taxon

    If verbose Then
      If Not eqstr(match.rank, "species") And
        Not eqstr(match.rank, "subspecies") And
        Not eqstr(match.rank, "variety") Then
        If Not eqstr(match.rank, "no taxon") And Not eqstr(match.rank, "stateofmatter") Then s &= " " & match.rank
      End If
    End If

    descr = getDescr(match, True)
    If descr <> "" Then s &= " (" & descr & ")"
    If isQuery Then s &= "  " & match.imageCounter & "/" & match.childimageCounter

    Return s

  End Function

  Function queryTax(cmd As String, val As String) As List(Of taxrec)

    ' load matches from cmd query

    Dim match As taxrec
    Dim matches As New List(Of taxrec)
    '```
    Using ds As DataSet = getDS(cmd, val)
      If ds IsNot Nothing Then
        For Each dr As DataRow In ds.Tables(0).Rows
          match = getTaxrec(dr, True)
          If match.taxid <> "" Then matches.Add(match)
        Next dr
      End If
    End Using

    Return matches

  End Function


  Public Sub populate(ByRef node As TreeNode, ByVal isQuery As Boolean)
    ' populate a single tree node from the database

    Dim matches As List(Of taxrec)

    Dim nd As TreeNode
    Dim found As Boolean

    If isQuery Then
      matches = queryTax("select * from taxatable where parentid = @parm1 and childimagecounter > 0 order by taxon", node.Tag)

    Else
      matches = queryTax("select * from taxatable where parentid = @parm1 order by taxon", node.Tag)
    End If

    For Each m As taxrec In matches
      found = False
      For Each nd In node.Nodes
        If nd.Tag = m.taxid Then ' don't add duplicate
          found = True
          Exit For
        End If
      Next nd

      If Not found Then
        nd = node.Nodes.Add(taxaLabel(m, False, isQuery))
        nd.ToolTipText = m.rank
        nd.Tag = m.taxid
      End If
    Next m

  End Sub

  Function getDescr(ByRef inMatch As taxrec, ByVal shortForm As Boolean) As String

    ' start at taxonkey, then ascend through the parents until a description is found.
    ' shortform is true to omit "Family: Brushfoot etc."

    Dim match As taxrec
    Dim parent As String
    Dim iter As Integer = 0
    Dim taxid As String

    If inMatch.taxid = "" Then Return ""

    If inMatch.parentid = "" Then ' inmatch might only have the taxonid
      ' load everything else into inmatch
      taxid = inMatch.taxid
      inMatch = getTaxrecByID(taxid, True)
    End If

    If inMatch.descr <> "" Or shortForm Then Return inMatch.descr
    parent = inMatch.parentid

    Do While parent > "" And iter < 25
      iter += 1
      match = getTaxrecByID(parent, True)
      If match.taxid = "" Then Return ""

      If match.descr <> "" AndAlso Not eqstr(match.rank, "No Taxon") And
           (Not eqstr(match.rank, "Species") Or eqstr(inMatch.rank, "Subspecies")) And
           Not eqstr(match.rank, "Subspecies") And
           Not eqstr(match.rank, "Variety") Then
        Return match.rank & ": " & match.descr
      End If
      parent = match.parentid
    Loop

    Return ""

  End Function

  Function popuTaxon(ByVal xtaxi As String, ByRef tvTax As TreeView, ByVal isQuery As Boolean) As taxrec
    ' populate the tvTax and open it to taxi

    Dim nd As TreeNode
    Dim ndc As TreeNode = Nothing
    Dim ndParent As TreeNode
    Dim ids As New List(Of Integer)
    Dim topMatch As New taxrec
    Dim matches As List(Of taxrec)
    Dim ancestor As List(Of taxrec)
    Dim i As Integer

    Dim ndTarget As TreeNode
    Dim targetLevel As Integer ' level in tvTax of the match

    tvTax.Visible = True

    ' search for the taxon
    matches = TaxonSearch(xtaxi, isQuery)

    ndTarget = Nothing
    targetLevel = 999
    ndParent = tvTax.Nodes(0) ' 2/28/20
    populate(ndParent, isQuery)

    For Each match As taxrec In matches
      ancestor = getancestors(match, "")  ' retrieve ancestors of ancestor(0). false = don't exclude "no taxons"
      ndParent = tvTax.Nodes(0) ' 2/28/20

      For i = ancestor.Count - 2 To 0 Step -1  ' go through ancestors top down, starting at root's children
        ndc = Nothing

        For Each nd In ndParent.Nodes          ' search for next match
          If nd.Tag = ancestor(i).taxid Then
            ndc = nd
            Exit For
          End If

        Next nd

        ' add node to treeview if it's not already there
        If ndc Is Nothing Then
          ndc = ndParent.Nodes.Add(taxaLabel(ancestor(i), False, isQuery))
          'If ancestor(i).descr = "" Then
          '  ndc = ndParent.Nodes.Add(ancestor(i).taxon)
          'Else
          '  ndc = ndParent.Nodes.Add(ancestor(i).taxon & " -- " & ancestor(i).descr)
          '  End If
          ndc.ToolTipText = ancestor(i).rank
          ndc.Tag = ancestor(i).taxid
        End If

        If ndc.Nodes.Count = 0 Then populate(ndc, isQuery)
        ndc.Expand()
        ndParent = ndc  ' descend one level
      Next i

      If ndc IsNot Nothing Then
        ndc.BackColor = nodeMatchColor
      Else
        ndParent.BackColor = nodeMatchColor
      End If

      If ancestor.Count < targetLevel Then ' save the top match
        ndTarget = ndc
        targetLevel = ancestor.Count
        topMatch = match
      End If

    Next match

    ' highlight the top match
    tvTax.SelectedNode = ndTarget
    tvTax.Select()

    Return topMatch

  End Function

  Function getancestors(m As taxrec, StopAt As String) As List(Of taxrec)

    Dim match As taxrec
    Dim ancestor As New List(Of taxrec)
    Dim iter As Integer = 0
    Dim taxid As String

    ancestor.Add(m)
    taxid = m.parentid

    Do While taxid <> "" And iter < 50
      match = getTaxrecByID(taxid, True)
      If match.taxid = "" Then Return ancestor
      ancestor.Add(match)
      If eqstr(match.rank, StopAt) Then Return ancestor
      taxid = match.parentid
      iter += 1
    Loop

    Return ancestor

  End Function

  Sub getQueryPaths(ByRef fileNames As List(Of String), ByVal initialize As Boolean)
    ' gets file names from bugquery into fileNames()

    'If Clipboard.ContainsText Then QueryTaxon = Clipboard.GetText '` temporary!!!

    If initialize Or queryNames Is Nothing Then
      If useQuery Then ' bugs
        Using frm As New chk
          frm.ShowDialog()
        End Using
      End If
    End If
    fileNames.AddRange(queryNames)

  End Sub
  Sub gotoNextNode(tvTax As TreeView)

    ' select the next node with treeMatchColor

    Dim ndStart As TreeNode
    Dim done As Boolean
    Dim mode As Integer

    ndStart = tvTax.SelectedNode

    mode = 0
    done = traverse(tvTax.Nodes(0), ndStart, mode, tvTax) ' 0 means to skip the current node nd

    mode = 1
    If Not done Then done = traverse(tvTax.Nodes(0), ndStart, mode, tvTax) ' wrap

  End Sub

  Function traverse(nd As TreeNode, startNode As TreeNode, ByRef mode As Integer, tvTax As TreeView) As Boolean

    ' mode = 0 means to skip nd

    Dim done As Boolean

    If mode = 0 AndAlso nd Is startNode Then
      mode = 1
    Else

      If mode = 1 AndAlso nd.BackColor = nodeMatchColor Then
        tvTax.SelectedNode = nd
        nd.EnsureVisible()
        ' tvTax.Select()
        Return True
      End If
    End If

    For Each ndc As TreeNode In nd.Nodes
      done = traverse(ndc, startNode, mode, tvTax)
      If done Then Return True
    Next ndc

    Return False

  End Function

  Sub linkImageSet(ByVal fName As String, ByVal linktoFname As String)
    ' adds fname's imageid to an imageSet with linktoFname's id. Creates a new imageset if it doesn't exist.
    ' 3 ids in this table: image, set, and unique ID

    Dim setid As Integer
    Dim linktoID As Integer

    ' get imageset.imageid from filenames
    linktoID = getScalar("select imageid from images where filename = @parm1 limit 1", linktoFname)
    If linktoID <= 0 Then Exit Sub

    ' find existing previous link
    setid = getScalar("select setid from imagesets where imageid = @parm1 limit 1", linktoID)

    If setid <= 0 Then ' no existing imageset - make one
      saveImageSetID(linktoID, setid) ' assigns setid
    End If

    saveImageSet(fName, setid) ' save the one for the new file

  End Sub

  Sub saveImageSetID(ByVal imageID As Integer, ByRef setID As Integer)
    ' make a new imagset record.
    ' if setID is zero, it replaces it with the new setID value.
    ' deletes other setIDs for this imageid

    Dim i As Integer

    If imageID <= 0 Then Exit Sub

    i = nonQuery("delete from imagesets where imageid = @parm1", imageID)
    i = nonQuery("insert into imagesets (imageid, setid) values (@parm1, @parm2)", imageID, setID)

    If setID <= 0 Then ' no existing imageset - make a unique setID
      ' set setid to the id of the imageset record just created, to make sure it's not in use
      setID = getScalar("select id from imagesets where setid = @parm1 and imageid = @parm2", setID, imageID)
      i = nonQuery("update imagesets set setid = @parm1 where id = @parm1", setID)
    End If

  End Sub

  Sub saveImageSet(ByVal fName As String, ByRef setID As Integer)
    ' save an imageset record for fName with setID. May replace an existing one.

    Dim i As Integer
    Dim newUid, oldSetid As Integer
    Dim imageID As Integer

    imageID = getScalar("select imageid from images where filename = @parm1 limit 1", fName)

    If imageID <= 0 Then Exit Sub

    If setID <= 0 Then ' create a record with a new setid
      saveImageSetID(imageID, setID)
      Exit Sub
    End If

    ' find existing link for current image
    Using ds As DataSet = getDS("select id, setid from imagesets where imageid = @parm1", imageID)
      If ds Is Nothing Then Exit Sub

      If ds.Tables.Count > 0 And ds.Tables(0).Rows.Count > 0 Then
        newUid = ds.Tables(0).Rows(0)("id")
        oldSetid = ds.Tables(0).Rows(0)("setid")
      Else
        newUid = 0
      End If

      If newUid <= 0 Then
        ' add current image to new imageset record
        i = nonQuery("insert into imagesets (imageid, setid) values (@parm1, @parm2)", imageID, setID)
      Else
        ' add current image to existing imageset record
        i = nonQuery("update imagesets set imageid = @parm1, setid = @parm2 where id = @parm3", imageID, setID, newUid)
        ' delete the rest of the old imageset if there's only one image left
        i = getScalar("select count(*) from imagesets where setid = @parm1", oldSetid)
        If i = 1 Then ' delete it
          i = nonQuery("delete from imagesets where setid = @parm1", oldSetid)
        End If
      End If
    End Using

  End Sub

  Sub bugDelete(ByVal fName As String)

    Dim i, imageID, setID As Integer
    Dim taxID As String

    imageID = getScalar("select imageid from images where filename = @parm1 limit 1", fName)
    taxID = getScalar("select taxonid from images where imageid = @parm1 limit 1", imageID)
    setID = getScalar("select setid from imagesets where imageid = @parm1", imageID) ' save to check 1-member sets
    i = nonQuery("delete from imagesets where imageid = @parm1", imageID) ' delete the imageset record
    i = nonQuery("delete from images where filename = @parm1", fName) ' delete the image record

    i = getScalar("select count(*) from imagesets where setid = @parm1", setID) ' how many left in the imageset
    If i = 1 Then ' delete the set if there is only one left
      i = nonQuery("delete from imagesets where setid = @parm1", setID)
    End If

    incImageCounter(taxID, -1)

  End Sub

  Sub deleteImageSets(ByVal fName As String)
    ' delete all imagesets for a filename

    Dim imageID As Integer
    Dim i As Integer

    imageID = getScalar("select imageid from images where filename = @parm1 limit 1", fName)
    If imageID > 0 Then i = nonQuery("delete from imagesets where imageid = @parm1", imageID)

  End Sub

  Function getTargetFilename(ByVal targetFolder As String, ByVal picpath As String, ByRef exists As Boolean) As String

    ' gets a file name for when the source(picpath) and targets(folder) are/have different folders (assumed)

    Dim oldtest As Boolean
    Dim i As Integer
    Dim s, s1, matchPath, fname As String
    Dim c As String
    Dim fnames As List(Of String)

    ' get txfilename.text - generate or find the file name
    s1 = targetFolder
    If Not s1.EndsWith("\") Then s1 &= "\"
    s = Path.GetFileNameWithoutExtension(picpath)


    ' append a-z... use a, or the last one that exists (if any do).
    ' find the last match with matching originalpath

    oldtest = False
    If Not oldtest Then
      c = ""
      exists = False
      fnames = Directory.GetFiles(s1, s & "?.jpg").ToList
      fnames.Sort()

      matchPath = picpath.Substring(1) ' any drive
      For i1 As Integer = fnames.Count - 1 To 0 Step -1
        fname = fnames(i1)
        c = Path.GetFileNameWithoutExtension(fname)
        c = c.Substring(c.Length - 1, 1)
        i = getScalar("SELECT count(*) FROM images WHERE substr(originalpath, 2) = @parm1 and filename = @parm2", matchPath, s & c & ".jpg")
        If i > 0 Then
          exists = True
          Return (s & c & ".jpg")  ' filename without path
        End If
      Next i1

      If c = "" Then c = "a" Else c = Chr(Asc(c) + 1)
      Return (s & c & ".jpg")  ' filename without path

    Else
      Dim lastpicmatch As String = ""
      lastpicmatch = ""
      c = ""
      If File.Exists(s1 & s & c & ".jpg") Then
        Do While File.Exists(s1 & s & c & ".jpg")
          ' find the last match with matching originalpath
          matchPath = picpath.Substring(1) ' any drive
          i = getScalar("SELECT count(*) FROM images WHERE substr(originalpath, 2) = @parm1 and filename = @parm2", matchPath, s & c & ".jpg")
          If i > 0 Then lastpicmatch = c
          c = Chr(Asc(c) + 1)
        Loop

        If lastpicmatch <> "" Then
          c = lastpicmatch
          exists = True
        Else
          exists = False
        End If
      Else
        exists = False
      End If

      Return (s & c & ".jpg")  ' filename without path
    End If

  End Function

  Public Sub GPSLocate(ByVal latlon As String, ByRef locale As String, ByRef county As String, ByRef state As String, ByRef country As String)

    ' gets the County, State from Google for the latlon

    Dim url As String
    Dim s As String
    Dim dLat, dLon As Double
    Dim jq As JObject

    latlonVerify(latlon, dLat, dLon)

    'link = "http://maps.googleapis.com/maps/api/geocode/xml?sensor=true&latlng=" & Format(dLat, "###.#####") & "," & Format(dLon, "###.#####")
    url = "http://nominatim.openstreetmap.org/reverse?format=json&lat=" & Format(dLat, "###.#####") & "&lon=" & Format(dLon, "###.#####") &
           "&zoom=18&addressdetails=1&email=bob-mud@xpda.com"

    Try
      s = qClient.GetStringAsync(url).Result
      jq = JObject.Parse(s)
    Catch ex As Exception
      MsgBox(ex.Message)
      Exit Sub
    End Try

    If jq.SelectToken("address") IsNot Nothing Then
      If jq.SelectToken("address.city") IsNot Nothing Then
        locale = jq.SelectToken("address.city").ToString
      ElseIf jq.SelectToken("address.town") IsNot Nothing Then
        locale = jq.SelectToken("address.town").ToString
        'ElseIf jq.SelectToken("address.village") IsNot Nothing Then
        '  locale = jq.SelectToken("address.village").ToString
      End If
      If jq.SelectToken("address.county") IsNot Nothing Then county = jq.SelectToken("address.county").ToString Else county = ""
      If jq.SelectToken("address.state") IsNot Nothing Then state = jq.SelectToken("address.state").ToString Else state = ""
      If jq.SelectToken("address.country") IsNot Nothing Then country = jq.SelectToken("address.country").ToString Else country = ""
    End If

    If LCase(county).EndsWith(" county") Then county = county.Substring(0, county.Length - 7)
    If LCase(locale) = "pryor creek" Then locale = "Pryor"
    If states.ContainsKey(state) Then state = states(state) ' get state abbreviation

    If country = "United States" Or country = "USA" Or country = "U.S." Or country = "United States of America" Then country = ""
    If country = "United Kingdom" Then country = "UK"

  End Sub

  Function getDS(ByVal scmd As String, Optional ByRef parm1 As Object = "", Optional ByRef parm2 As Object = "", Optional ByRef parm3 As Object = "") As DataSet

    ' returns ds, uses @parm1 and @parm2 in query

    Dim cmd As MySqlCommand
    Dim da As New MySqlDataAdapter

    Using ds As DataSet = New DataSet
      Try
        Using conn As New MySqlConnection(iniDBConnStr)
          conn.Open()
          cmd = New MySqlCommand(scmd, conn)
          cmd.Parameters.AddWithValue("@parm1", parm1)
          cmd.Parameters.AddWithValue("@parm2", parm2)
          cmd.Parameters.AddWithValue("@parm3", parm3)
          da.SelectCommand = cmd
          da.Fill(ds)
        End Using
      Catch ex As Exception
        MsgBox("Error, getDS: " & ex.Message)
        Return Nothing
      End Try

      Return ds
    End Using

  End Function

  Function getScalar(ByVal scmd As String,
    Optional ByRef parm1 As Object = "", Optional ByRef parm2 As Object = "", Optional ByRef parm3 As Object = "") As Object

    ' returns ds, uses @parm1 and @parm2 in query
    Dim cmd As MySqlCommand
    Dim q As Object

    Try
      Using conn As New MySqlConnection(iniDBConnStr)
        conn.Open()
        cmd = New MySqlCommand(scmd, conn)
        cmd.Parameters.AddWithValue("@parm1", parm1)
        cmd.Parameters.AddWithValue("@parm2", parm2)
        cmd.Parameters.AddWithValue("@parm3", parm3)
        q = cmd.ExecuteScalar
        Return q
      End Using
    Catch ex As Exception
      MsgBox("Error, getScalar: " & ex.Message)
      Return Nothing
    End Try

  End Function

  Function nonQuery(ByVal scmd As String,
    Optional ByRef parm1 As Object = "", Optional ByRef parm2 As Object = "", Optional ByRef parm3 As Object = "") As Object

    ' returns ds, uses @parm1 and @parm2 in query

    Dim cmd As MySqlCommand
    Dim i As Integer

    Try
      Using conn As New MySqlConnection(iniDBConnStr)
        conn.Open()
        cmd = New MySqlCommand(scmd, conn)
        cmd.Parameters.AddWithValue("@parm1", parm1)
        cmd.Parameters.AddWithValue("@parm2", parm2)
        cmd.Parameters.AddWithValue("@parm3", parm3)
        i = cmd.ExecuteNonQuery
        Return i
      End Using
    Catch ex As Exception
      Return 0
      MsgBox("Error, nonQuery: " & ex.Message)
    End Try

  End Function

  Function TaxonSearch(findme As String, isQuery As Boolean) As List(Of taxrec)

    ' get dataset taxatable record for taxon or common name findme

    Dim m As New taxrec
    Dim matches As New List(Of taxrec)
    Dim matches2 As List(Of taxrec)
    Dim rDescr As String
    Dim suffix As String

    findme = findme.Trim
    If findme = "" Then Return matches

    rDescr = findme.Replace("-", "`") ' accept either space or dash, so "eastern tailed blue" finds "eastern tailed-blue". Only works with rlike (mysql bug).
    rDescr = rDescr.Replace(" ", "[- ]")
    rDescr = rDescr.Replace("`", "[- ]")
    rDescr = rDescr.Replace("(", "\(")
    rDescr = rDescr.Replace(")", "\)")


    If findme = "OLYMPUS DIGITAL CAMERA" Then Return matches ' empty list

    If isQuery Then
      suffix = " and (childimagecounter > 0) order by taxon"
      'suffixg = " and usable <> '' order by name"
    Else
      suffix = " order by taxon"
      'suffixg = "  and usable <> '' order by name"
    End If

    matches = queryTax("select * from taxatable where taxon = @parm1" & suffix, findme)
    If matches.Count > 0 Then Return matches ' exact taxon match

    ' search for equal descr
    matches = queryTax("select * from oddinfo join taxatable using (taxid) where commonnames rlike @parm1 order by taxon", rDescr)
    matches2 = queryTax("select * from taxatable where descr rlike @parm1 order by taxon", rDescr)
    matches = mergeMatches(matches, matches2)
    If matches.Count > 0 Then Return matches


    If matches.Count = 0 Then matches = queryTax("select * from taxatable where (taxon like @parm1)" & suffix, findme & "%")
    If matches.Count = 0 Then
      matches = queryTax("select * from taxatable where (taxon like @parm1)" & suffix, "%" & findme & "%")
    End If

    matches2 = queryTax("select * from oddinfo join taxatable using (taxid) where commonnames rlike @parm1 order by taxon",
                        "%" & rDescr & "%")
    matches = mergeMatches(matches, matches2)
    matches2 = queryTax("select * from taxatable where taxon rlike @parm1 or descr rlike @parm1 order by taxon", "%" & rDescr & "%")
    matches = mergeMatches(matches, matches2)

    Return matches

  End Function

  Function checkDB(ByVal connStr As String) As Boolean

    Try
      Using conn As New MySqlConnection(connStr)
        conn.Open()
      End Using
    Catch ex As Exception
      Return False
    End Try

    Return True

  End Function

  Function getConnStr(ByVal host As String, ByVal database As String, ByVal user As String, ByVal password As String) As String
    Return "server=" & host & "; database=" & database & "; uid=" & user & "; pwd=" & password & "; allowuservariables=true;"
  End Function

  Sub incImageCounter(ByVal taxid As String, ByVal inc As Integer)

    ' add inc to imagecounter and childimagecounter for taxid and its ancestors

    Dim i As Integer
    Dim imageCounter, childImageCounter As Integer
    Dim parentID As String
    Dim m As taxrec

    m = getTaxrecByID(taxid, True)
    If m.taxid = "" Then Exit Sub ' error

    imageCounter = m.imageCounter
    childImageCounter = m.childimageCounter
    imageCounter += inc
    childImageCounter += inc

    i = nonQuery("update taxatable set imagecounter = @parm1, childimagecounter = @parm2 where taxid = @parm3",
        imageCounter, childImageCounter, taxid)
    If i <> 1 Then Stop

    parentID = m.parentid
    ' follow parentID up the taxon tree, incrementing childImageCounter
    For k As Integer = 1 To 200
      If Not IsNumeric(parentID) Then Exit For

      m = getTaxrecByID(parentID, True)
      If m.taxid = "" Then Exit For ' error

      childImageCounter = m.childimageCounter
      childImageCounter += inc

      i = nonQuery("update taxatable set childimagecounter = @parm1 where taxid = @parm2", childImageCounter, parentID)
      If i <> 1 Then Stop
      If i = 1 Then parentID = m.parentid
    Next k

  End Sub

  Function getCaption(ByRef pic As pixClass) As String

    Dim s As String
    Dim s1 As String
    Dim descr As String
    Dim taxonkey As String

    s = ""

    descr = getDescr(pic.match, False)
    If descr <> "" AndAlso Not descr.Contains(":") Then s &= descr & "<br>"

    taxonkey = pic.match.taxon
    s &= "<i>" & taxonkey & "</i>"
    If Not eqstr(pic.match.rank, "species") And
      Not eqstr(pic.match.rank, "subspecies") And
      Not eqstr(pic.match.rank, "no taxon") Then
      s &= " " & pic.match.rank
    End If
    s &= "<br>"

    If descr <> "" AndAlso descr.Contains(":") Then s &= descr & "<br>"

    s1 = LocationLabel(pic)
    If s1 <> "" Then s &= s1 & "<br>"

    If pic.Remarks <> Nothing AndAlso pic.Remarks <> "" Then s &= "Remarks: " & pic.Remarks & "<br>"
    If pic.Size <> Nothing AndAlso pic.Size <> "" Then s &= "Size: " & pic.Size & "<br>"
    If pic.photoDate <> Nothing Then s &= Format(pic.photoDate, "d")

    's &= vbCrLf & "</div>"

    Return (s)

  End Function

  Function getCalCaption(ByRef pic As pixClass) As String

    ' get a caption for the calendar, not html

    Dim s As String
    Dim s1 As String
    Dim taxonkey As String

    s = ""

    taxonkey = pic.match.taxon
    s += taxonkey ' tags will be removed on output
    If Not eqstr(pic.match.rank, "species") And
      Not eqstr(pic.match.rank, "subspecies") And
      Not eqstr(pic.match.rank, "no taxon") Then
      s &= " " & pic.match.rank
    End If

    s1 = getDescr(pic.match, False) ' get next higher rank description
    If s1 <> "" Then s &= ", " & s1

    s += vbCrLf

    s1 = LocationLabel(pic)
    If pic.photoDate <> Nothing Then
      If s1 <> "" Then s1 &= ", "
      s1 &= Format(pic.photoDate, "MMMM") & " " & Format(pic.photoDate, "yyyy")
    End If
    If s1 <> "" Then s &= s1 & vbCrLf

    s1 = ""
    If pic.Size <> Nothing AndAlso pic.Size <> "" Then s1 = pic.Size
    If pic.Remarks <> Nothing AndAlso pic.Remarks <> "" Then
      If s1 <> "" Then s1 &= ", "
      s1 &= "Remarks: " & pic.Remarks & vbCrLf
    End If
    If s1 <> "" Then s &= s1

    Return (s)

  End Function

  Function LocationLabel(ByVal pic As pixClass) As String

    Dim s As String

    s = ""
    If pic.Location <> "" Then
      s += pic.Location
      If pic.County <> "" Or pic.State <> "" Or pic.Country <> "" Then s += ", "
    End If
    If pic.County <> "" Then
      s += pic.County
      If pic.Country = "" And Not eqstr(pic.State, "AK") Then s += " County" ' U.S. only.
      If pic.State <> "" Or pic.Country <> "" Then s += ", "
    End If
    If pic.State <> "" Then
      s += pic.State
      If pic.Country <> "" Then s += ", "
    End If
    If pic.Country <> "" Then s += pic.Country

    Return s

  End Function

  Function getChildren(tMatch As taxrec, dballowed As Integer, withPics As Boolean) As List(Of taxrec)

    ' get all the immediate children of tmatch, in all database tables

    Dim desc As New List(Of taxrec)
    Dim descg As New List(Of taxrec)
    Dim childNames As New List(Of String)
    Dim pics As String = ""

    If withPics Then pics = " and childimagecounter > 0 "

    If (dballowed And 1) Then
      desc = queryTax("select * from taxatable where parentid = @parm1" & pics, tMatch.taxid)

      For Each m As taxrec In desc
        childNames.Add(m.taxon)
      Next m
    End If

    Return desc

  End Function

  Function validTaxon(m As taxrec) As String

    Dim s As String

    s = LCase(m.taxon)
    If s.Split(" ").Length >= 3 OrElse
        s.Contains(" ") OrElse
        s.Contains("""") OrElse
        s.Contains("(") OrElse
        s.Contains("--") OrElse
        s.Contains("-cf-") OrElse
        s.Contains("-new-") OrElse
        s.Contains("-non-") OrElse
        s.Contains("-nr-") OrElse
        s.Contains("-or-") OrElse
        s.Contains("-sp-") OrElse
        s.Contains("-idae") OrElse
        s.Contains(".") OrElse
        s.Contains("/") OrElse
        s.Contains("assigned") OrElse
        s.Contains("adventive") OrElse
        s.Contains("established") OrElse
        s.Contains("incertae") OrElse
        s.Contains("introduction") OrElse
        s.Contains("maybe") OrElse
        s.Contains("near-") OrElse
        s.Contains("possible") OrElse
        s.Contains("possibly") OrElse
        s.Contains("likely") OrElse
        s.Contains("probably") OrElse
        s.Contains("sensu lato") OrElse
        s.Contains("suspected") OrElse
        s.Contains("undescribed") OrElse
        s.Contains("undetermined") OrElse
        s.Contains("known") OrElse
        s.Contains("unnamed") OrElse
        s.Contains("placed") OrElse
        s.EndsWith("-cf") OrElse
        s.EndsWith("-like") OrElse
        s.EndsWith("-sp") OrElse
        s.EndsWith("complex") OrElse
        s.EndsWith("group") OrElse
        s.EndsWith("pseudo") OrElse
        s.StartsWith("cf-") OrElse
        s.StartsWith("n-") OrElse
        s.StartsWith("new-") OrElse
        s.StartsWith("non-") OrElse
        s.StartsWith("nr-") OrElse
        s.StartsWith("on-") OrElse
        s.StartsWith("-xxxx") OrElse
        s.StartsWith("sp-") Then Return "non-taxonomic text in name."

    If Not itisRankID.ContainsKey(m.rank) Then Return "Invalid rank in taxa."

    Return ""

  End Function

  Function allDescendants(tMatch As taxrec, rank As String) As List(Of taxrec)
    ' returns a sorted list of itis + bugguide descendant names, at rank (or all descendants if rank is "")

    Dim children As List(Of taxrec)
    Dim chil As List(Of taxrec)
    Dim desc As New List(Of taxrec) ' all the descendants to return
    Dim childName As New List(Of String)
    Dim descName As New List(Of String)
    'Dim validName As String
    Dim recRank As String

    children = getChildren(tMatch, 1, False) ' get immediate children, sources = dballowed, include with or without pics

    For i1 As Integer = children.Count - 1 To 0 Step -1
      'validName = validTaxon(children(i1))
      'If validName = "" Then
      recRank = children(i1).rank
      If rank = "" OrElse eqstr(rank, recRank) Then
        If descName.IndexOf(children(i1).taxon) < 0 Then ' add new taxrec
          descName.Add(children(i1).taxon)
          desc.Add(children(i1))
        Else
          children.RemoveAt(i1)
        End If

      ElseIf (itisRankID.ContainsKey(recRank) AndAlso itisRankID(rank) <= itisRankID(recRank)) Then ' rank is as low as target
        children.RemoveAt(i1)
      End If

      'End If
    Next i1

    For Each m As taxrec In children
      chil = allDescendants(m, rank)
      For Each m2 As taxrec In chil
        If descName.IndexOf(m2.taxon) < 0 Then ' add new taxrec
          descName.Add(m2.taxon)
          desc.Add(m2)
        End If
      Next m2
    Next m

    sortTaxrec(desc)

    Return desc

  End Function

  Sub sortTaxrec(ByRef children As List(Of taxrec))
    ' sort a list of taxrecs
    ' this is ugly. I am lazy.

    Dim ix As New List(Of Integer)
    Dim keys As New List(Of String)
    Dim sorted As New List(Of taxrec)

    For i1 As Integer = 0 To children.Count - 1
      ix.Add(i1)
      keys.Add(children(i1).taxon)
      sorted.Add(New taxrec)
    Next i1
    MergeSort(keys, ix, 0, ix.Count - 1)
    For i1 As Integer = 0 To ix.Count - 1
      sorted(i1) = children(ix(i1))
    Next i1
    children = New List(Of taxrec)
    children.AddRange(sorted)

  End Sub

End Module



Public Class pixClass
  Public fName As String
  Public photoDate As DateTime
  Public Location As String
  Public County As String
  Public State As String
  Public Country As String
  Public Size As String
  Public imageid As Integer
  Public Remarks As String
  Public match As taxrec

  Sub New(ByRef dr As DataRow)

    ' sourceDB is blank for taxatable
    Dim s As String

    fName = dr("filename")
    photoDate = dr("photodate")
    Location = dr("location")
    County = dr("county")
    State = dr("state")
    Country = dr("country")
    Size = dr("size")
    imageid = dr("imageid")
    Remarks = dr("remarks")

    s = dr("taxonid")

    match = getTaxrec(dr, False)

  End Sub

End Class
